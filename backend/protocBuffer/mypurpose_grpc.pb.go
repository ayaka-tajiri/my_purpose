// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package my_purpose

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// MyPurposeClient is the client API for MyPurpose service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MyPurposeClient interface {
	IndexPurposes(ctx context.Context, in *PurposeRequest, opts ...grpc.CallOption) (MyPurpose_IndexPurposesClient, error)
	ShowPurpose(ctx context.Context, in *PurposeRequest, opts ...grpc.CallOption) (*PurposeResponse, error)
	CreatePurpose(ctx context.Context, in *PurposeRequest, opts ...grpc.CallOption) (*PurposeResponse, error)
	EditPurpose(ctx context.Context, in *PurposeRequest, opts ...grpc.CallOption) (*PurposeResponse, error)
	DeletePurpose(ctx context.Context, in *PurposeRequest, opts ...grpc.CallOption) (*PurposeResponse, error)
	IndexActions(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (MyPurpose_IndexActionsClient, error)
	EditAction(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionResponse, error)
	CreateAction(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionResponse, error)
	DeleteAction(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionResponse, error)
	IndexCalendars(ctx context.Context, in *CalendarRequest, opts ...grpc.CallOption) (MyPurpose_IndexCalendarsClient, error)
}

type myPurposeClient struct {
	cc grpc.ClientConnInterface
}

func NewMyPurposeClient(cc grpc.ClientConnInterface) MyPurposeClient {
	return &myPurposeClient{cc}
}

func (c *myPurposeClient) IndexPurposes(ctx context.Context, in *PurposeRequest, opts ...grpc.CallOption) (MyPurpose_IndexPurposesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_MyPurpose_serviceDesc.Streams[0], "/my_purpose.MyPurpose/IndexPurposes", opts...)
	if err != nil {
		return nil, err
	}
	x := &myPurposeIndexPurposesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MyPurpose_IndexPurposesClient interface {
	Recv() (*PurposeResponse, error)
	grpc.ClientStream
}

type myPurposeIndexPurposesClient struct {
	grpc.ClientStream
}

func (x *myPurposeIndexPurposesClient) Recv() (*PurposeResponse, error) {
	m := new(PurposeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *myPurposeClient) ShowPurpose(ctx context.Context, in *PurposeRequest, opts ...grpc.CallOption) (*PurposeResponse, error) {
	out := new(PurposeResponse)
	err := c.cc.Invoke(ctx, "/my_purpose.MyPurpose/ShowPurpose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myPurposeClient) CreatePurpose(ctx context.Context, in *PurposeRequest, opts ...grpc.CallOption) (*PurposeResponse, error) {
	out := new(PurposeResponse)
	err := c.cc.Invoke(ctx, "/my_purpose.MyPurpose/CreatePurpose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myPurposeClient) EditPurpose(ctx context.Context, in *PurposeRequest, opts ...grpc.CallOption) (*PurposeResponse, error) {
	out := new(PurposeResponse)
	err := c.cc.Invoke(ctx, "/my_purpose.MyPurpose/EditPurpose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myPurposeClient) DeletePurpose(ctx context.Context, in *PurposeRequest, opts ...grpc.CallOption) (*PurposeResponse, error) {
	out := new(PurposeResponse)
	err := c.cc.Invoke(ctx, "/my_purpose.MyPurpose/DeletePurpose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myPurposeClient) IndexActions(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (MyPurpose_IndexActionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_MyPurpose_serviceDesc.Streams[1], "/my_purpose.MyPurpose/IndexActions", opts...)
	if err != nil {
		return nil, err
	}
	x := &myPurposeIndexActionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MyPurpose_IndexActionsClient interface {
	Recv() (*ActionResponse, error)
	grpc.ClientStream
}

type myPurposeIndexActionsClient struct {
	grpc.ClientStream
}

func (x *myPurposeIndexActionsClient) Recv() (*ActionResponse, error) {
	m := new(ActionResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *myPurposeClient) EditAction(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionResponse, error) {
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, "/my_purpose.MyPurpose/EditAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myPurposeClient) CreateAction(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionResponse, error) {
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, "/my_purpose.MyPurpose/CreateAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myPurposeClient) DeleteAction(ctx context.Context, in *ActionRequest, opts ...grpc.CallOption) (*ActionResponse, error) {
	out := new(ActionResponse)
	err := c.cc.Invoke(ctx, "/my_purpose.MyPurpose/DeleteAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *myPurposeClient) IndexCalendars(ctx context.Context, in *CalendarRequest, opts ...grpc.CallOption) (MyPurpose_IndexCalendarsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_MyPurpose_serviceDesc.Streams[2], "/my_purpose.MyPurpose/IndexCalendars", opts...)
	if err != nil {
		return nil, err
	}
	x := &myPurposeIndexCalendarsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MyPurpose_IndexCalendarsClient interface {
	Recv() (*CalendarResponse, error)
	grpc.ClientStream
}

type myPurposeIndexCalendarsClient struct {
	grpc.ClientStream
}

func (x *myPurposeIndexCalendarsClient) Recv() (*CalendarResponse, error) {
	m := new(CalendarResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MyPurposeServer is the server API for MyPurpose service.
// All implementations must embed UnimplementedMyPurposeServer
// for forward compatibility
type MyPurposeServer interface {
	IndexPurposes(*PurposeRequest, MyPurpose_IndexPurposesServer) error
	ShowPurpose(context.Context, *PurposeRequest) (*PurposeResponse, error)
	CreatePurpose(context.Context, *PurposeRequest) (*PurposeResponse, error)
	EditPurpose(context.Context, *PurposeRequest) (*PurposeResponse, error)
	DeletePurpose(context.Context, *PurposeRequest) (*PurposeResponse, error)
	IndexActions(*ActionRequest, MyPurpose_IndexActionsServer) error
	EditAction(context.Context, *ActionRequest) (*ActionResponse, error)
	CreateAction(context.Context, *ActionRequest) (*ActionResponse, error)
	DeleteAction(context.Context, *ActionRequest) (*ActionResponse, error)
	IndexCalendars(*CalendarRequest, MyPurpose_IndexCalendarsServer) error
	mustEmbedUnimplementedMyPurposeServer()
}

// UnimplementedMyPurposeServer must be embedded to have forward compatible implementations.
type UnimplementedMyPurposeServer struct {
}

func (UnimplementedMyPurposeServer) IndexPurposes(*PurposeRequest, MyPurpose_IndexPurposesServer) error {
	return status.Errorf(codes.Unimplemented, "method IndexPurposes not implemented")
}
func (UnimplementedMyPurposeServer) ShowPurpose(context.Context, *PurposeRequest) (*PurposeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowPurpose not implemented")
}
func (UnimplementedMyPurposeServer) CreatePurpose(context.Context, *PurposeRequest) (*PurposeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePurpose not implemented")
}
func (UnimplementedMyPurposeServer) EditPurpose(context.Context, *PurposeRequest) (*PurposeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditPurpose not implemented")
}
func (UnimplementedMyPurposeServer) DeletePurpose(context.Context, *PurposeRequest) (*PurposeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePurpose not implemented")
}
func (UnimplementedMyPurposeServer) IndexActions(*ActionRequest, MyPurpose_IndexActionsServer) error {
	return status.Errorf(codes.Unimplemented, "method IndexActions not implemented")
}
func (UnimplementedMyPurposeServer) EditAction(context.Context, *ActionRequest) (*ActionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditAction not implemented")
}
func (UnimplementedMyPurposeServer) CreateAction(context.Context, *ActionRequest) (*ActionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAction not implemented")
}
func (UnimplementedMyPurposeServer) DeleteAction(context.Context, *ActionRequest) (*ActionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAction not implemented")
}
func (UnimplementedMyPurposeServer) IndexCalendars(*CalendarRequest, MyPurpose_IndexCalendarsServer) error {
	return status.Errorf(codes.Unimplemented, "method IndexCalendars not implemented")
}
func (UnimplementedMyPurposeServer) mustEmbedUnimplementedMyPurposeServer() {}

// UnsafeMyPurposeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MyPurposeServer will
// result in compilation errors.
type UnsafeMyPurposeServer interface {
	mustEmbedUnimplementedMyPurposeServer()
}

func RegisterMyPurposeServer(s grpc.ServiceRegistrar, srv MyPurposeServer) {
	s.RegisterService(&_MyPurpose_serviceDesc, srv)
}

func _MyPurpose_IndexPurposes_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PurposeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MyPurposeServer).IndexPurposes(m, &myPurposeIndexPurposesServer{stream})
}

type MyPurpose_IndexPurposesServer interface {
	Send(*PurposeResponse) error
	grpc.ServerStream
}

type myPurposeIndexPurposesServer struct {
	grpc.ServerStream
}

func (x *myPurposeIndexPurposesServer) Send(m *PurposeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MyPurpose_ShowPurpose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PurposeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyPurposeServer).ShowPurpose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/my_purpose.MyPurpose/ShowPurpose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyPurposeServer).ShowPurpose(ctx, req.(*PurposeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyPurpose_CreatePurpose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PurposeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyPurposeServer).CreatePurpose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/my_purpose.MyPurpose/CreatePurpose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyPurposeServer).CreatePurpose(ctx, req.(*PurposeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyPurpose_EditPurpose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PurposeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyPurposeServer).EditPurpose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/my_purpose.MyPurpose/EditPurpose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyPurposeServer).EditPurpose(ctx, req.(*PurposeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyPurpose_DeletePurpose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PurposeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyPurposeServer).DeletePurpose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/my_purpose.MyPurpose/DeletePurpose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyPurposeServer).DeletePurpose(ctx, req.(*PurposeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyPurpose_IndexActions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ActionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MyPurposeServer).IndexActions(m, &myPurposeIndexActionsServer{stream})
}

type MyPurpose_IndexActionsServer interface {
	Send(*ActionResponse) error
	grpc.ServerStream
}

type myPurposeIndexActionsServer struct {
	grpc.ServerStream
}

func (x *myPurposeIndexActionsServer) Send(m *ActionResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _MyPurpose_EditAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyPurposeServer).EditAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/my_purpose.MyPurpose/EditAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyPurposeServer).EditAction(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyPurpose_CreateAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyPurposeServer).CreateAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/my_purpose.MyPurpose/CreateAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyPurposeServer).CreateAction(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyPurpose_DeleteAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MyPurposeServer).DeleteAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/my_purpose.MyPurpose/DeleteAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MyPurposeServer).DeleteAction(ctx, req.(*ActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MyPurpose_IndexCalendars_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CalendarRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MyPurposeServer).IndexCalendars(m, &myPurposeIndexCalendarsServer{stream})
}

type MyPurpose_IndexCalendarsServer interface {
	Send(*CalendarResponse) error
	grpc.ServerStream
}

type myPurposeIndexCalendarsServer struct {
	grpc.ServerStream
}

func (x *myPurposeIndexCalendarsServer) Send(m *CalendarResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _MyPurpose_serviceDesc = grpc.ServiceDesc{
	ServiceName: "my_purpose.MyPurpose",
	HandlerType: (*MyPurposeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ShowPurpose",
			Handler:    _MyPurpose_ShowPurpose_Handler,
		},
		{
			MethodName: "CreatePurpose",
			Handler:    _MyPurpose_CreatePurpose_Handler,
		},
		{
			MethodName: "EditPurpose",
			Handler:    _MyPurpose_EditPurpose_Handler,
		},
		{
			MethodName: "DeletePurpose",
			Handler:    _MyPurpose_DeletePurpose_Handler,
		},
		{
			MethodName: "EditAction",
			Handler:    _MyPurpose_EditAction_Handler,
		},
		{
			MethodName: "CreateAction",
			Handler:    _MyPurpose_CreateAction_Handler,
		},
		{
			MethodName: "DeleteAction",
			Handler:    _MyPurpose_DeleteAction_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "IndexPurposes",
			Handler:       _MyPurpose_IndexPurposes_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "IndexActions",
			Handler:       _MyPurpose_IndexActions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "IndexCalendars",
			Handler:       _MyPurpose_IndexCalendars_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protocBuffer/mypurpose.proto",
}
